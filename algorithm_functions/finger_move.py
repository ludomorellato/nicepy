import sys

from functions.get_index_of_edge import get_index_of_edge
from functions.check_and_fix_basepoint_finger_move import check_and_fix_basepoint_finger_move, check_if_red_edge_on_new_region_cutted

# This function take as input a diagram, a starting region, an ending region, the regions
# through which we want to pass, the edges that we cut  (recall that they are always red edges)
# and the blue edge on which we operate the move.
# As a result, we update the Heegaard Diagram to the new version.



def finger_move(diagram, starting_region_label, ending_region_label, regions_to_go_through, edges_to_go_through, edge_to_bend):
	
	regions_input = diagram.regions_input.copy()
	number_intersection_points = diagram.number_intersection_points
	diagram.NEW_number_intersection_points = diagram.number_intersection_points + 2*len(edges_to_go_through)

	# From now on, all the modifications are going to be done on this list, so that we are going to take in 
	# account all the previous changes when we do a modification 

	# First of all, we fix the ending region. Doing it as first thing, we don't need to distnguish between
	# the case in which starting and ending region are the same or not.
	# As intersection points, we add the last two, as we would do if we were to do it by hand
	ending_region = regions_input[ending_region_label - 1] 	
	edge_to_go_through_index = get_index_of_edge(ending_region, edges_to_go_through[-1][::-1])

	# We then modify the ending_region in the regions_input, but we add the newly created bigon only at the end (so 
	# that also the index is going to be the last one between the indicies of regions generated by the finger move)

	ending_region = ending_region[:edge_to_go_through_index + 1] + [number_intersection_points + 2*len(edges_to_go_through), number_intersection_points + 2*len(edges_to_go_through) - 1] + ending_region[edge_to_go_through_index + 1:]
	ending_bigon = [number_intersection_points + 2*len(edges_to_go_through), number_intersection_points + 2*len(edges_to_go_through) - 1]

	regions_input[ending_region_label -1] = ending_region



	# For diagrams of 4-ended tangles:
	# We check if ending_region is a region with basepoint
	if diagram.is_tangle_diagram:

		check_and_fix_basepoint_finger_move(diagram, ending_region_label, edges_to_go_through[-1][::-1], [edges_to_go_through[-1][1], number_intersection_points + 2*len(edges_to_go_through)])
		


	# Secondly, we operate on the starting region, on the other region that has the edge that we bend and the
	# ending region. 
	# The finger move cut the starting region in half, we split it and we fix the adjacent region.
	starting_region = regions_input[starting_region_label -1]

	'''
	# First we fix the starting region. We need to check first if it is a region with basepoint; we 
	# define a flag edge_with_basepoint, which is False if it is not a region with basepoint and
	# it is the edge on which the basepoint is (in the case that the diagram is bordered) and it is
	# True if the region has a basepoint in its interior


	HOW CAN I UNDERSTAND ON WHICH EDGE I HAVE THE EVENTUAL BASEPOINT?
	I MEAN, IF WE HAVE A BORDER REGION WITH MORE THAN ONE BORDER EDGE?
	HOW DO I DECIDE WHERE TO PUT THE BASEPOINT?

	ANSWER: if I do the finger move correctly, I never have to split it in a difficult way.
	The only problem would be in the beginning finger move, but I never split a region with a basepoint.
	
	
	if label_starting_region in diagram.regions_with_basepoint:
		if diagram.regions[label_starting_region].is_border:
	'''

	# We understand which is the right indecies from which to cut the region
	edge_to_bend_index = get_index_of_edge(starting_region, edge_to_bend)
	
	edge_to_go_through_index = get_index_of_edge(starting_region, edges_to_go_through[0])

	# We cut the starting_region in the two regions and we save the result in regions_input
	# (notice that we cannot go out with the indicies by adding only 1, we are only saying that 
	# we want also the elment of that index exaclty)
	if edge_to_bend_index < edge_to_go_through_index:
		starting_region_cutted = starting_region[edge_to_bend_index + 1:edge_to_go_through_index + 1]+[number_intersection_points + 1]
		starting_region = [number_intersection_points+2] + starting_region[edge_to_go_through_index + 1:] + starting_region[0:edge_to_bend_index + 1]
	else:
		starting_region_cutted = starting_region[edge_to_bend_index + 1:] + starting_region[0:edge_to_go_through_index + 1]+[number_intersection_points + 1]
		starting_region = [number_intersection_points+2] + starting_region[edge_to_go_through_index + 1:edge_to_bend_index + 1]
	



	# We check if we are modifying a border region, in such case we want to leave the border region 
	# with the label fixed. Remark that we can't generate two different border region with a move
	if diagram.regions[starting_region_label].is_border:
		
		# The modified region was is a border region, we must check
		if min(starting_region) <= diagram.number_border_points:
			# The border region is already fixed, we don't need to do anything
			pass
		else:
			# We border region is starting_region_cutted, therefore we switch them
			starting_region, starting_region_cutted = starting_region_cutted, starting_region
	else:

		# The modified region is not a border one, we don't need to do anything
		pass





	# For diagrams of 4-ended tangles:
	# We check if starting_region is a region with basepoint
	if diagram.is_tangle_diagram:
		
		check_and_fix_basepoint_finger_move(diagram, starting_region_label, edges_to_go_through[0], [number_intersection_points + 2, edges_to_go_through[0][1]])

		# We also need to check if, when we have cut starting region in two,
		# the red edge with the basepoint is remained in starting_region
		# or if it went in starting_region_cutted
		check_if_red_edge_on_new_region_cutted(diagram, starting_region_label, starting_region_cutted, len(regions_input)+1)


	regions_input[starting_region_label -1] = starting_region
	regions_input.append(starting_region_cutted)




	# We fix now the other region that has the bent edge
	neighbour_region = False
	for [candidate_region, edge] in diagram.regions[starting_region_label].blue_neighbours:
		if edge == edge_to_bend:
			neighbour_region = candidate_region
			break
	
	
	neighbour_region_input = regions_input[neighbour_region.label - 1]

	edge_to_fix_index = get_index_of_edge(neighbour_region_input, edge_to_bend[::-1])
	
	new_neighbour_region = neighbour_region_input[0: edge_to_fix_index + 1] + [number_intersection_points+1, number_intersection_points+2] + neighbour_region_input[edge_to_fix_index + 1:]
	regions_input[neighbour_region.label -1] = new_neighbour_region



	# We add the number of intersection points that we have added for now
	# (recall that we also used the last two intersection points, but we don't add them yet)
	number_intersection_points = number_intersection_points + 2



	# We can now iterate the procedure on the middle regions
	for index in range(len(regions_to_go_through)):

		middle_region = regions_input[regions_to_go_through[index] - 1]


		# We distinguish between being in the last region and not being in the last region
		if index == (len(regions_to_go_through) -1):		# To distinguish between two cases is not really needed, but I think it is more clear
			
			# We are in the last step, therefore we have already add the last two intersection 
			# points (we did it in the beginning when we fixed the ending region), therefore we 
			# add these two points to our counter
			number_intersection_points = number_intersection_points + 2

			# Sanity check
			if number_intersection_points != diagram.NEW_number_intersection_points:
				sys.exit("Number of intersection points added not right, check the code")

			# If we are in the last of the regions to go through, we already have added the last two 
			# intersection points in the ending region. We only need to cut this middle region in three 
			# different regions and to fix the intersection points on this side

			# First, we find the index of the red edge of the ending bigon (which is the common edge)
			edge_ending_bigon_index = get_index_of_edge(middle_region, edges_to_go_through[-1])
			
			# Then we need the index of the red edge that we use to enter in the region
			edge_entering_middle_region_index = get_index_of_edge(middle_region, edges_to_go_through[-2][::-1])

			
			# We can now generate the new two regions and modify the last middle region

			# First we create the square region that we generate
			square_region = [number_intersection_points - 2, number_intersection_points - 3, number_intersection_points -1, number_intersection_points]
			
			# We cut the ending_region in the two regions
			if edge_entering_middle_region_index < edge_ending_bigon_index:
				middle_region_cutted = [number_intersection_points - 3] + middle_region[edge_entering_middle_region_index + 1:edge_ending_bigon_index + 1] + [number_intersection_points - 1]
				middle_region = [number_intersection_points] + middle_region[edge_ending_bigon_index + 1:] + middle_region[0:edge_entering_middle_region_index + 1] + [number_intersection_points - 2]
			else:
				middle_region_cutted = [number_intersection_points - 3] + middle_region[edge_entering_middle_region_index + 1:] + middle_region[0:edge_ending_bigon_index + 1]+[number_intersection_points - 1]
				middle_region = [number_intersection_points] + middle_region[edge_ending_bigon_index + 1:edge_entering_middle_region_index + 1] + [number_intersection_points - 2]
			
			'''
			AS IT IS WITHOUT THE FOLLOWING, WE LEAVE FIXED THE LEFT PART (LEFT IN THE SENSE OF THE 
			DIRECTION OF THE FINGER MOVE). IS IT OKAY OR DO WE ACTUALLY WANT TO LEAVE FIXED THE BIGGER 
			PIECE?
			IN THE LATTER CASE, PUT THE FOLLOWING SNIPPET OUT OF THE COMMENT

			# We want to leave the middle region to be the bigger one, therefore we check 
			# the lenght of the two
			if len(middle_region) < len(middle_region_cutted):
				middle_region, middle_region_cutted = middle_region_cutted, middle_region
			'''



			# We check if we are modifying a border region, in such case we want to leave the border region 
			# with the label fixed. Remark that we can't generate two different border region with a move
			if diagram.regions[regions_to_go_through[index]].is_border:
				
				# The modified region was is a border region, we must check
				if min(middle_region) <= diagram.number_border_points:
					# The border region is already fixed, we don't need to do anything
					pass
				else:
					# We border region is starting_region_cutted, therefore we switch them
					middle_region, middle_region_cutted = middle_region_cutted, middle_region
			else:

				# The modified region is not a border one, we don't need to do anything
				pass



			
			# For diagrams of 4-ended tangles:
			# We check if middle_region is a region with basepoint in the case in which we have
			# closed the surface
			if diagram.is_tangle_diagram:

				# We check if the edge from which we are entering has a basepoint
				check_and_fix_basepoint_finger_move(diagram, regions_to_go_through[index], edges_to_go_through[-2][::-1], [edges_to_go_through[-2][1], number_intersection_points - 2])
				
				# We check if the edge from which we are exiting has a basepoint
				check_and_fix_basepoint_finger_move(diagram, regions_to_go_through[index], edges_to_go_through[-1], [number_intersection_points, edges_to_go_through[-1][1]])




			# We save all the results in regions_input
			regions_input[regions_to_go_through[index] -1] = middle_region
			regions_input.append(middle_region_cutted)
			regions_input.append(square_region)





		else:

			# We are in the middle of a region to cut through.
			# We already have added the two intersection points in the prevoius region on the common edge;
			# we only need to cut this middle region in three regions and to fix the intersection points 
			# on the commonedge with the previous region on this side.

			# First, we find the index of the red edge from which we'll go out from the region
			edge_exiting_middle_region_index = get_index_of_edge(middle_region, edges_to_go_through[index + 1])
			
			
			# Then we need the index of the red edge that we use to enter in the region
			edge_entering_middle_region_index = get_index_of_edge(middle_region, edges_to_go_through[index][::-1])
			
			
			# We can now generate the new two regions and modify the ending region

			# First we create the square region that we generate
			square_region = [number_intersection_points, number_intersection_points - 1, number_intersection_points + 1, number_intersection_points + 2]
			
			# Then we cut the ending_region in the two regions
			if edge_entering_middle_region_index < edge_exiting_middle_region_index:
				middle_region_cutted = [number_intersection_points - 1] + middle_region[edge_entering_middle_region_index + 1:edge_exiting_middle_region_index + 1] + [number_intersection_points + 1]
				middle_region = [number_intersection_points + 2] + middle_region[edge_exiting_middle_region_index + 1:] + middle_region[0:edge_entering_middle_region_index + 1] + [number_intersection_points]
			else:
				middle_region_cutted = [number_intersection_points - 1] + middle_region[edge_entering_middle_region_index + 1:] + middle_region[0:edge_exiting_middle_region_index + 1]+[number_intersection_points + 1]
				middle_region = [number_intersection_points + 2] + middle_region[edge_exiting_middle_region_index + 1:edge_entering_middle_region_index + 1] + [number_intersection_points]
			
			
			'''
			AS IT IS WITHOUT THE FOLLOWING, WE LEAVE FIXED THE LEFT PART (LEFT IN THE SENSE OF THE 
			DIRECTION OF THE FINGER MOVE). IS IT OKAY OR DO WE ACTUALLY WANT TO LEAVE FIXED THE BIGGER 
			PIECE?
			IN THE LATTER CASE, PUT THE FOLLOWING SNIPPET OUT OF THE COMMENT
			
			# We want to leave the middle region to be the bigger one, therefore we check 
			# the lenght of the two
			if len(middle_region) < len(middle_region_cutted):
				middle_region, middle_region_cutted = middle_region_cutted, middle_region
			'''

			# We check if we are modifying a border region, in such case we want to leave the border region 
			# with the label fixed. Remark that we can't generate two different border region with a move
			if diagram.regions[regions_to_go_through[index]].is_border:
				
				# The modified region was is a border region, we must check
				if min(middle_region) <= diagram.number_border_points:
					# The border region is already fixed, we don't need to do anything
					pass
				else:
					# We border region is middle_region_cutted, therefore we switch them
					middle_region, middle_region_cutted = middle_region_cutted, middle_region
			else:

				# The modified region is not a border one, we don't need to do anything
				pass
			

			
			
			# For diagrams of 4-ended tangles:
			# We check if middle_region is a region with basepoint in the case in which we have
			# closed the surface
			if diagram.is_tangle_diagram:
				

				# We check if the edge from which we are entering has a basepoint
				check_and_fix_basepoint_finger_move(diagram, regions_to_go_through[index], edges_to_go_through[index][::-1], [edges_to_go_through[index][1], number_intersection_points])
				
				# We check if the edge from which we are exiting has a basepoint
				check_and_fix_basepoint_finger_move(diagram, regions_to_go_through[index], edges_to_go_through[index + 1], [number_intersection_points + 2, edges_to_go_through[index + 1][1]])



			# We save all the results in regions_input
			regions_input[regions_to_go_through[index] -1] = middle_region
			regions_input.append(middle_region_cutted)
			regions_input.append(square_region)
			


			# We have added two intersection points, therefore we increment the number
			number_intersection_points = number_intersection_points + 2

		
		
		


	
	# Laslty, we append the ending bigon that we created in the beginning
	regions_input.append(ending_bigon)


	# We can now update our diagram
	# We modify the attributes
	diagram.NEW_regions_input = regions_input
	diagram.NEW_number_intersection_points = number_intersection_points

	# We update the diagram
	diagram.update_diagram()