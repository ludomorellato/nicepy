import sys
import copy

from functions.get_index_of_edge import get_index_of_edge
from functions.inner_circle_handleslide import inner_circle_handleslide
from functions.inner_circle_handleslide_slow import inner_circle_handleslide_slow
from functions.check_and_fix_basepoint_handleslide import check_and_fix_basepoint_handleslide_starting_region_first_edge, check_and_fix_basepoint_handleslide_starting_region_last_edge, check_if_red_edge_on_starting_region_cutted_handleslide, check_and_fix_basepoint_handleslide, check_if_red_edge_on_new_region_cutted

# This function is quite similar to the one for the finger move.
# Howeverl notice that in this case we always have that starting and ending regions coincide.

# This function take as input a diagram, a starting (and ending) region, the regions
# through which we want to pass, the edges that we cut  (recall that they are always red edges)
# and the blue edge on which we operate the handle slide, called "edge_to_slide".
# As a result, we update the Heegaard Diagram to the new version.



def handle_slide(diagram, starting_region_label, regions_to_go_through, edges_to_go_through, edge_to_slide):


	regions_input = copy.deepcopy(diagram.regions_input)
	number_intersection_points = diagram.number_intersection_points
	diagram.NEW_number_intersection_points = diagram.number_intersection_points + len(edges_to_go_through)

	# From now on, all the modifications are going to be done on this list, so that we are going to take in 
	# account all the previous changes when we do a modification 
	

	
	# As first thing, we understand which is the inner blue circle on which we slide on.
	# This is needed in the case of a 4-ended tangle diagram
	inner_circle_zipped = inner_circle_handleslide(diagram, starting_region_label, regions_to_go_through, edges_to_go_through)
	
	
	# We first fix the starting region and the neighbour region with the slid edge.
	# As intersection points, we add the first and the last, as we would do if we were to do it by hand

	starting_region = regions_input[starting_region_label - 1]

	# We recover the index of the first edge to go through
	first_edge_index = get_index_of_edge(starting_region, edges_to_go_through[0])
	

	# We rewrite the input of the starting region in a way that the first edge is the first edge to 
	# go through with the handle slide (and we assign the right index to first_edge_index)
	starting_region = starting_region[first_edge_index: ] + starting_region[: first_edge_index]
	first_edge_index = 0

	# We now compute also the other two indices that we need from the starting region, i.e. the one 
	# of the last edge that we go through and the one of the edge to slide
	last_edge_index = get_index_of_edge(starting_region, edges_to_go_through[-1][::-1])
	edge_to_slide_index = get_index_of_edge(starting_region, edge_to_slide)
	

	

	# We need also to find the first blue edge that we are sliding on in the first region, so 
	# that we can know on which "side" is the inner blue circle is
	if last_edge_index == len(starting_region) - 2:

		first_blue_edge_starting_region = [starting_region[-1], starting_region[0]]
	
	else:

		first_blue_edge_starting_region = starting_region[1:3]

		# We also need to invert the order of inner_circle_zipped
		inner_circle_zipped = inner_circle_zipped[::-1]

	# We order the inner circle starting from the first blue edge (in the first region that we cut)
	first_blue_edge_index = inner_circle_zipped.index(first_blue_edge_starting_region) + 1
	inner_circle_zipped = inner_circle_zipped[first_blue_edge_index: ] + inner_circle_zipped[: first_blue_edge_index]



	# We recover now the neighbour region that has the slid edge
	neighbour_region = False
	for [candidate_region, edge] in diagram.regions[starting_region_label].blue_neighbours:
		if edge == edge_to_slide:
			neighbour_region = candidate_region
			break
	
	neighbour_region_input = regions_input[neighbour_region.label - 1]

	# And we find the index of such edge for this region
	edge_to_fix_neighbour_index = get_index_of_edge(neighbour_region_input, edge_to_slide[::-1])
	

	# We then modify the neighbour and the starting_region in the regions_input.
	# Remark that we add the newly created region (the one resulting from cutting the starting region) only at the end,
	# so that also the index is going to be the last one between the indicies of regions generated by the handle slide.
	# Remark also that, if we operate as in the original paper, the starting_region_cuttted is a bigon, but we implement 
	# this procedure in a more general way
	 
	if edge_to_slide_index < last_edge_index:
		new_neighbour_region = neighbour_region_input[0: edge_to_fix_neighbour_index + 1] + [number_intersection_points + len(edges_to_go_through)] + starting_region[last_edge_index + 1:] + [starting_region[0], number_intersection_points + 1] + neighbour_region_input[edge_to_fix_neighbour_index + 1:]
		starting_region_cutted = starting_region[edge_to_slide_index + 1: last_edge_index + 1] + [number_intersection_points + len(edges_to_go_through)]
		starting_region = [number_intersection_points + 1] + starting_region[1:edge_to_slide_index + 1]
	else:
		# Notice that this is always the case in the algorithm as it is presented by the original paper
		new_neighbour_region = neighbour_region_input[0: edge_to_fix_neighbour_index + 1] + [number_intersection_points + 1] + starting_region[1:last_edge_index+1] + [number_intersection_points + len(edges_to_go_through)] + neighbour_region_input[edge_to_fix_neighbour_index + 1:]
		starting_region_cutted = [starting_region[0]] + [number_intersection_points + 1] + starting_region[edge_to_slide_index + 1:]
		starting_region = [number_intersection_points + len(edges_to_go_through)] + starting_region[last_edge_index + 1: edge_to_slide_index + 1]





	# For diagrams of 4-ended tangles:
	# We check if starting_region is a region with basepoint in the case in which we have
	# closed the surface
	
	if diagram.is_tangle_diagram:

		if starting_region_label in diagram.basepoint_regions_and_red_edges.keys():

			# If the region has a basepoint, we check if it have modified the associated red edge
			# We want to leave the basepoint distant from the inner blue circle that we slide on,
			# for the first region this means to decide if we have to put it on the half red edge 
			# remaining in "starting_region_cutted" or in the half red edge in "starting_region"
			# (recall that we do an handleslide only if the first edge that we go through and the 
			# last edge that we go through are separate only by one blue edge
			

			# We create the new entry for starting_region_cutted in the basepoint dictionary,
			# it will eventually remain empty
			diagram.basepoint_regions_and_red_edges[len(regions_input)] = []

			# We check the entering edge
			check_and_fix_basepoint_handleslide_starting_region_first_edge(diagram, starting_region_label, len(regions_input), edge_to_slide_index, last_edge_index, edges_to_go_through[0], [number_intersection_points + 1, edges_to_go_through[0][1]], [edges_to_go_through[0][0], number_intersection_points + 1])


			# We check the exiting edge
			check_and_fix_basepoint_handleslide_starting_region_last_edge(diagram, starting_region_label, len(regions_input), edge_to_slide_index, last_edge_index, edges_to_go_through[-1][::-1], [number_intersection_points + len(edges_to_go_through), edges_to_go_through[0][0]], [edges_to_go_through[-1][1], number_intersection_points + len(edges_to_go_through)])			


			# We check if there was a basepoint in starting_region that was not modified by the move
			# but stayied in starting_region_cutted and hence is to modify in the basepoint dictionary
			check_if_red_edge_on_starting_region_cutted_handleslide(diagram, starting_region_label, starting_region_cutted, len(regions_input))



	# We modify the input in the regions_input
	regions_input[neighbour_region.label -1] = new_neighbour_region
	regions_input[starting_region_label -1] = starting_region
	regions_input.append(starting_region_cutted)



	# We add the number of intersection points that we have added for now
	# (recall that we also used the last intersection point, but we don't add it yet)
	number_intersection_points = number_intersection_points + 1



	
	# We can now iterate the procedure on the middle regions
	for index in range(len(regions_to_go_through)):
		
		middle_region = regions_input[regions_to_go_through[index] -1]
		blue_edge_sliding_on = inner_circle_zipped[index]


		# We distinguish between being in the last region and not being in the last region
		if index == (len(regions_to_go_through) -1):			# # To dstinguish between two cases is not really needed, but I think it is more clear
			
			# We are in the last step, therefore we have already add the last intersection 
			# point (we did it in the beginning when we fixed the starting region), therefore we 
			# add this point to our counter
			number_intersection_points = number_intersection_points + 1

			# Sanity check
			if number_intersection_points != diagram.NEW_number_intersection_points:
				sys.exit("Number of intersection points added not right, check the code")

			# If we are in the last of the regions to go through, we already have added the last 
			# intersection point in the starting region. We only need to cut this middle region in two 
			# different regions and to fix the intersection points on this side

			# First, we find the index of the red edge for the exit (which is the common edge with the 
			# starting region)
			edge_exiting_middle_region_index = get_index_of_edge(middle_region, edges_to_go_through[-1])
			
			
			# Then we need the index of the red edge that we use to enter in the region
			edge_entering_middle_region_index = get_index_of_edge(middle_region, edges_to_go_through[-2][::-1])

			
			# We can now generate the new region and modify the last middle region

			if edge_entering_middle_region_index < edge_exiting_middle_region_index:
				middle_region_cutted = [number_intersection_points - 1] + middle_region[edge_entering_middle_region_index + 1:edge_exiting_middle_region_index + 1] + [number_intersection_points]
				middle_region = [number_intersection_points] + middle_region[edge_exiting_middle_region_index + 1:] + middle_region[0:edge_entering_middle_region_index + 1] + [number_intersection_points - 1]
			else:
				middle_region_cutted = [number_intersection_points - 1] + middle_region[edge_entering_middle_region_index + 1:] + middle_region[0:edge_exiting_middle_region_index + 1] + [number_intersection_points]
				middle_region = [number_intersection_points] + middle_region[edge_exiting_middle_region_index + 1:edge_entering_middle_region_index + 1] + [number_intersection_points - 1]
			
			


			# We want to call middle_region_cutted the rectangle generated by te handleslide.
			# Therefore we check if blue_edge_sliding_on is already in middle_region_cutted or if we need to swap the two regions
			blue_edges_middle_region_cutted = list(map(list, zip(middle_region_cutted, middle_region_cutted[1:]+ [middle_region_cutted[0]])))[1::2]
			blue_edges_middle_region = list(map(list, zip(middle_region, middle_region[1:]+ [middle_region[0]])))[1::2]

			if blue_edge_sliding_on in blue_edges_middle_region_cutted:

				# It is already fine, we pass
				pass
			
			elif blue_edge_sliding_on in blue_edges_middle_region:

				# We swap the regions
				middle_region, middle_region_cutted = middle_region_cutted, middle_region
			
			else:

				# If we end here, there is an error
				sys.exit('Error: while doing the handleslide, we are not able to understand which one between middle_region and middle_region_cutted is the one next to the inner circle')


			'''
			# We check if we are modifying a border region, in such case we want to leave the border region 
			# with the label fixed. Remark that we can't generate two different border region with a move
			if diagram.regions[regions_to_go_through[index]].is_border:
				
				# The modified region was is a border region, we must check
				if min(middle_region) <= diagram.number_border_points:
					# The border region is already fixed, we don't need to do anything
					pass
				else:
					# We border region is middle_region_cutted, therefore we switch them
					middle_region, middle_region_cutted = middle_region_cutted, middle_region
			else:

				# The modified region is not a border one, we don't need to do anything
				pass
			'''



			# For diagrams of 4-ended tangles:
			# We check if middle_region is a region with basepoint in the case in which we have
			# closed the surface
			if diagram.is_tangle_diagram:

				check_and_fix_basepoint_handleslide(diagram, regions_to_go_through[index], middle_region, edges_to_go_through[index][::-1], edges_to_go_through[index + 1], number_intersection_points)
				


			# We save all the results in regions_input
			regions_input[regions_to_go_through[index] -1] = middle_region
			regions_input.append(middle_region_cutted)




		else:

			# We are in the middle of a region to cut through.
			# We already have added the an intersection point in the prevoius region on the common edge;
			# we only need to cut this middle region in two regions and to fix the intersection point 
			# on the commonedge with the previous region on this side.

			# We are going to add an intersection point, therefore we increment the counter
			number_intersection_points = number_intersection_points + 1

			# We find the index of the red edge that we use for exiting from the region
			edge_exiting_middle_region_index = get_index_of_edge(middle_region, edges_to_go_through[index + 1])
			
			
			# Then we need the index of the red edge that we use to enter in the region
			edge_entering_middle_region_index = get_index_of_edge(middle_region, edges_to_go_through[index][::-1])
			
			
			# We can now generate the new region and modify the last middle region

			if edge_entering_middle_region_index < edge_exiting_middle_region_index:
				middle_region_cutted = [number_intersection_points - 1] + middle_region[edge_entering_middle_region_index + 1:edge_exiting_middle_region_index + 1] + [number_intersection_points]
				middle_region = [number_intersection_points] + middle_region[edge_exiting_middle_region_index + 1:] + middle_region[0:edge_entering_middle_region_index + 1] + [number_intersection_points - 1]
			else:
				middle_region_cutted = [number_intersection_points - 1] + middle_region[edge_entering_middle_region_index + 1:] + middle_region[0:edge_exiting_middle_region_index + 1] + [number_intersection_points]
				middle_region = [number_intersection_points] + middle_region[edge_exiting_middle_region_index + 1:edge_entering_middle_region_index + 1] + [number_intersection_points - 1]
			
			
			


			# We want to call middle_region_cutted the rectangle generated by te handleslide.
			# Therefore we check if blue_edge_sliding_on is already in middle_region_cutted or if we need to swap the two regions
			blue_edges_middle_region_cutted = list(map(list, zip(middle_region_cutted, middle_region_cutted[1:]+ [middle_region_cutted[0]])))[1::2]
			blue_edges_middle_region = list(map(list, zip(middle_region, middle_region[1:]+ [middle_region[0]])))[1::2]

			if blue_edge_sliding_on in blue_edges_middle_region_cutted:

				# It is already fine, we pass
				pass
			
			elif blue_edge_sliding_on in blue_edges_middle_region:

				# We swap the regions
				middle_region, middle_region_cutted = middle_region_cutted, middle_region
			
			else:

				# If we end here, there is an error
				sys.exit('Error: while doing the handleslide, we are not able to understand which one between middle_region and middle_region_cutted is the one next to the inner circle')


			'''
			# We check if we are modifying a border region, in such case we want to leave the border region 
			# with the label fixed. Remark that we can't generate two different border region with a move
			if diagram.regions[regions_to_go_through[index]].is_border:
				
				# The modified region was is a border region, we must check
				if min(middle_region) <= diagram.number_border_points:
					# The border region is already fixed, we don't need to do anything
					pass
				else:
					# We border region is middle_region_cutted, therefore we switch them
					middle_region, middle_region_cutted = middle_region_cutted, middle_region
			else:

				# The modified region is not a border one, we don't need to do anything
				pass
			'''





			# For diagrams of 4-ended tangles:
			# We check if middle_region is a region with basepoint in the case in which we have
			# closed the surface
			if diagram.is_tangle_diagram:

				check_and_fix_basepoint_handleslide(diagram, regions_to_go_through[index], middle_region, edges_to_go_through[index][::-1], edges_to_go_through[index + 1], number_intersection_points)
				




			# We save all the results in regions_input
			regions_input[regions_to_go_through[index] -1] = middle_region
			regions_input.append(middle_region_cutted)
			


		
		
		




	# We can now update our diagram
	# We modify the attributes
	diagram.NEW_regions_input = regions_input
	diagram.NEW_number_intersection_points = number_intersection_points

	# We update the diagram
	diagram.update_diagram()